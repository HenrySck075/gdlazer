#include "Container.hpp"

#include "../../input/events/MouseEvent.hpp"
#include "../../input/events/MouseDragEvent.hpp"
#include "../../utils/h2dContainer.hpp"
#include "../../../utils.hpp"

GDF_NS_START

void Container::setMinSize(const cocos2d::CCSize &size) {
  assert(m_maxSize.width > 0 || size.width >= m_maxSize.width);
  assert(m_maxSize.height > 0 || size.height >= m_maxSize.height);
  m_minSize = size;
}

void Container::setMaxSize(const cocos2d::CCSize &size) {
  assert(m_minSize.width > 0 || size.width >= m_minSize.width);
  assert(m_minSize.height > 0 || size.height >= m_minSize.height);
  m_maxSize = size;
}

float Container::processUnit(float value, Unit unit, bool isWidth) {
  switch (unit) {
  case Unit::Percent:
    if (getParent() == nullptr) return value;
    return value / 100.0f *
           (isWidth ? getParent()->getContentSize().width
                    : getParent()->getContentSize().height);
  case Unit::Viewport:
    return value *
           (isWidth
                ? cocos2d::CCDirector::sharedDirector()->getWinSize().width
                : cocos2d::CCDirector::sharedDirector()->getWinSize().height);
  case Unit::OpenGL:
    return value;
  case Unit::UIKit:
    return value /
           (isWidth
                ? (cocos2d::CCDirector::sharedDirector()
                       ->getOpenGLView()
                       ->getFrameSize()
                       .width /
                   cocos2d::CCDirector::sharedDirector()->getWinSize().width)
                : (cocos2d::CCDirector::sharedDirector()
                       ->getOpenGLView()
                       ->getFrameSize()
                       .height /
                   cocos2d::CCDirector::sharedDirector()->getWinSize().height));
  default:
    return value;
  }
}

bool Container::init() {
    if (!CCClippingNode::init())
        return false;

    m_borderNode = cocos2d::CCDrawNode::create();
    this->addChild(m_borderNode, -999);

    m_backgroundNode = cocos2d::CCDrawNode::create();
    this->addChild(m_backgroundNode, -998);
    
    setStencil(cocos2d::CCDrawNode::create());

    // main handler that processes MouseDown & MouseUp event to others when applicable
    this->addListener<MouseEvent>([this](MouseEvent *mouseEvent) {
      auto currentPos = convertToNodeSpaceA(this, mouseEvent->m_position);
      bool isInBounds = m_containerBox!=nullptr && m_containerBox->isSomethingInside(h2d::Point2dF{
        currentPos.x, currentPos.y
      });
      //geode::log::debug("[Container]: {} | {} | {}", isInBounds, currentPos, (intptr_t)m_containerBox);
      if (!isInBounds) {
        mouseEvent->stopPropagation();
        if (mouseEvent->m_eventType!=MouseEventType::Move) goto fish;
      }
      switch (mouseEvent->m_eventType) {
        case MouseEventType::MouseUp:
          if (m_isDragging) {
            m_isDragging = false;
            dispatchEvent(new MouseDragEvent(
              MouseDragEventType::Stop, 
              m_dragStartPos, currentPos, 
              m_lastDragOffset
            ));
          }
          break;
        case MouseEventType::MouseDown:
          m_lastMousePos = currentPos;
          m_dragStartPos = currentPos;  // Store initial position for drag
          break;
        case MouseEventType::Move: 
          if (m_isDragging) {
            m_lastDragOffset = currentPos - m_lastMousePos;
            dispatchEvent(new MouseDragEvent(
              MouseDragEventType::Move, 
              m_dragStartPos, currentPos, 
              m_lastDragOffset
            ));
          } else if (mouseEvent->m_clicked) {
            m_isDragging = true;
            dispatchEvent(new MouseDragEvent(MouseDragEventType::Start, currentPos, currentPos, CCPointZero));
          } else {
            if (m_lastInBounds != isInBounds) {
              dispatchEvent(new MouseEvent(isInBounds ? MouseEventType::Enter : MouseEventType::Exit, currentPos, mouseEvent->m_clicked));
            }
          }
          m_lastMousePos = currentPos;
          break;
        // Everything after this line is generated by the container itself
        case MouseEventType::Click:
          break;
        case MouseEventType::Exit:
          if (m_isDragging) {
              m_isDragging = false;
              // should we actually do this?
              dispatchEvent(new MouseDragEvent(MouseDragEventType::Stop, m_dragStartPos, currentPos, m_lastDragOffset));
          }
          mouseEvent->stopPropagation();
          break;
        case MouseEventType::Enter:
          mouseEvent->stopPropagation();
          break;
      }
fish:
      m_lastInBounds = isInBounds;
      return;
    });

    this->addListener<NodeLayoutUpdated>([this](NodeLayoutUpdated* event) {
      if (event->getContainer() == getParent()) {
        updateSizeWithUnit();
        updatePositionWithUnit();
      }
    });

    return true;
}

void Container::drawBorder() {
  m_borderNode->clear();
  m_backgroundNode->clear();
  auto stencil = geode::cast::typeinfo_cast<CCDrawNode*>(getStencil());
  stencil->clear();
  
  auto size = getContentSize();
  auto radius = m_borderRadius;
  
  if (m_clippingEnabled && stencil == nullptr) {
    /// this is wacky but like i have no idea why it crashes
    stencil = cocos2d::CCDrawNode::create();
    setStencil(stencil);
  }
  if (radius > 0) {
    const int segments = 20;
    cocos2d::CCPoint* vertices = new cocos2d::CCPoint[segments + 2];
    const float angle = 2.0f * M_PI / segments;
    
    // Draw corners
    for (int i = 0; i <= segments; i++) {
        float x = radius * cosf(i * angle);
        float y = radius * sinf(i * angle);
        
        if (i <= segments/4) {
            vertices[i] = ccp(size.width - radius + x, size.height - radius + y);
        } else if (i <= segments/2) {
            vertices[i] = ccp(radius + x, size.height - radius + y);
        } else if (i <= 3*segments/4) {
            vertices[i] = ccp(radius + x, radius + y);
        } else {
            vertices[i] = ccp(size.width - radius + x, radius + y);
        }
    }
    
    m_borderNode->drawPolygon(vertices, segments + 1, {0,0,0,0}, 1, {1,1,1,1});
    if (stencil) stencil->drawPolygon(vertices, segments + 1, {1,1,1,1}, 0, {0,0,0,0});
    
    // Draw background
    ccColor4F bgColor = ccc4FFromccc4B(m_backgroundColor);
    m_backgroundNode->drawPolygon(vertices, segments + 1, bgColor, 0, {0,0,0,0});
    
    delete[] vertices;
  } else {
    cocos2d::CCPoint amougis[4] {
      {0,0},
      {size.width, 0},
      size,
      {0,size.height}
    };
    // Draw rectangle background for no radius
    ccColor4F bgColor = ccc4FFromccc4B(m_backgroundColor);
    m_backgroundNode->drawPolygon(amougis, 4, bgColor, 0.f, bgColor);
    if (stencil) stencil->drawPolygon(amougis, 4, bgColor, 0.f, bgColor);
  }
}

void Container::visit() {
  if (m_clippingEnabled) {
    cocos2d::CCClippingNode::visit();
    drawBorder();
  } else {
    cocos2d::CCNode::visit();
  }
}

void Container::setBorderRadius(float radius) {
  m_borderRadius = radius;
  updateContainerBox();
}

void Container::setBackgroundColor(const ccColor4B& color) {
  m_backgroundColor = color;
}
void Container::setSize(const cocos2d::CCSize &size, Unit unit) {
  m_size = size;
  m_lastSizeUnit = unit;
  updateSizeWithUnit();
}
void Container::setPosition(cocos2d::CCPoint position, Unit unit) {
  m_positionA = position;
  m_lastPositionUnit = unit;
  updatePositionWithUnit();
}
void Container::setParent(cocos2d::CCNode *parent) {
  cocos2d::CCNode::setParent(parent);
  updateSizeWithUnit();
  updatePositionWithUnit();
}

void Container::updateSizeWithUnit() {
  float width = m_size.width,
  height = m_size.height;
  #define $applyConstraint(edge) \
  if (m_minSize.edge > 0) { \
  edge = std::max(edge, m_minSize.edge); \
  } \
  if (m_maxSize.edge > 0) { \
  edge = std::min(edge, m_maxSize.edge); \
  }

  $applyConstraint(width);
  $applyConstraint(height);
  #undef $applyConstraint

  setContentSize(cocos2d::CCSize(
    processUnit(width, m_lastSizeUnit, true),
    processUnit(height, m_lastSizeUnit, false)
  ));
  dispatchEvent(new NodeLayoutUpdated(this));
  updateContainerBox();
}

void Container::updatePositionWithUnit() {
  CCNode::setPosition(
    processUnit(m_positionA.x, m_lastPositionUnit, true),
    processUnit(m_positionA.y, m_lastPositionUnit, false)
  );
  // TODO: Change the mouse input to convert the position to local
  // (so i can remove this line)
  updateContainerBox();
}

void Container::setClippingEnabled(bool enabled) {
  //if (m_clippingEnabled == enabled) return;
  m_clippingEnabled = enabled;
  updateClipping();
}

void Container::updateClipping() {
  /*
  if (m_clippingEnabled) {
    setStencil(cocos2d::CCDrawNode::create());
  } else {
    setStencil(nullptr);
  }
  */
}
struct LogNestManager {
  LogNestManager() {
    geode::log::pushNest(geode::Mod::get());
  }
  ~LogNestManager() {
    geode::log::popNest(geode::Mod::get());
  }
};
bool Container::doDispatchEvent(Event *event, std::type_index type) {
  geode::Ref<Event> eventRefHolder(event);
  //LogNestManager logNest;
  // Handle the event
  if (!EventTarget::doDispatchEvent(event, type)) {
    return false;
  }

  if (event->m_propagateStopped) {
    return true;
  }
  // Propagate to children
  auto children = getChildren();
  if (children) {
    for (auto child : geode::cocos::CCArrayExt<cocos2d::CCNode>(children)) {
      // casting directly to Container makes it use this overridden
      // dispatchEvent function
      auto childContainer = geode::cast::typeinfo_cast<Container*>(child);
      if (childContainer == nullptr)
        continue;
      if (!childContainer->doDispatchEvent(event, type)) {
        return false;
      }
    }
  }
  return true;
};

template<typename T>
h2d::Point2d_<T> operator+(h2d::Point2d_<T> lhs, h2d::Point2d_<T> rhs) {
  return {
    lhs.getX()+rhs.getX(),
    lhs.getY()+rhs.getY()
  };
}
GDF_NS_END
#include "../../utils/h2dFormatter.hpp"
GDF_NS_START
void Container::updateContainerBox() {
  if (m_containerBox) delete m_containerBox;
  m_containerBox = nullptr;
  if (
    getContentSize() == cocos2d::CCSize{0,0} ||
    // doubt it is this
    getContentWidth() < m_borderRadius || getContentHeight() < m_borderRadius
  ) {
    //geode::log::warn("Homographies crash check failed for {}, no container box is created.", this);
    return;
  }
  auto cs2 = getContentSize() - (cocos2d::CCPoint{m_borderRadius, m_borderRadius});
  auto bl = h2d::Point2dF{m_borderRadius, m_borderRadius},
       tr = h2d::Point2dF{cs2.width, cs2.height};
  if (h2d::detail::shareCommonCoord(bl, tr)) {
    //geode::log::warn("Common coordinate check failed: {}, {} | {}", bl, tr, getContentSize());
    return;
  }
  h2d::FRectF innerRect {
    bl, tr
  };

  //geode::log::debug("inner rect of {}: {}", this, innerRect);

  m_containerBox = new h2dShapeContainer<float>{{
    innerRect
  }};
  if (m_borderRadius > 0) {
    auto ir4pt = innerRect.get4Pts();
    m_containerBox->shapes.insert(m_containerBox->shapes.end(), {
      // left, right
      h2d::FRectF {
        h2d::Point2dF{0, m_borderRadius},
        ir4pt[2]+h2d::Point2dF{m_borderRadius,0}
      },
      // top, bottom
      h2d::FRectF {
        h2d::Point2dF{m_borderRadius, 0},
        ir4pt[2]+h2d::Point2dF{0,m_borderRadius}
      },
      // circle corners
      h2d::CircleF{ir4pt[0], m_borderRadius},
      h2d::CircleF{ir4pt[1], m_borderRadius},
      h2d::CircleF{ir4pt[2], m_borderRadius},
      h2d::CircleF{ir4pt[3], m_borderRadius}
    }); 
  }
};
GDF_NS_END
